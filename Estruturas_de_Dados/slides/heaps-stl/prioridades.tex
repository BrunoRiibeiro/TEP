\section{Filas com Prioridades}

\begin{frame}[fragile]{Definição de filas com prioridades}

    \begin{itemize}
        \item As filas com prioridades são variações da fila onde os elementos são
            acessados ou inseridos de acordo com a prioridade estabelecida

        \item Assim, a estratégia FIFO não se mantém: o primeiro elemento a sair não é mais
            o primeiro a entrar, e sim o elemento com maior prioridade presente na fila

        \item O desafio é encontrar uma implementação eficiente

        \item Se os elementos são inseridos ordenadamente na fila, de acordo com a prioridade,
            a complexidade do método \code{c}{push()} é $O(N)$, e do método \code{c}{pop()} é 
            $O(1)$

        \item Se os elementos são inseridos no final da fila, e a prioridade é avaliada no
            momento do acesso, a complexidade do método \code{c}{push()} é $O(1)$, e do método 
            \code{c}{pop()} é $O(N)$
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Filas com prioridades em C++}

    \begin{itemize}
        \item A STL do C++ oferece um contêiner que implementa uma fila com prioridades: a
            \code{c}{priority_queue}, que faz parte da biblioteca \code{c}{queue}

        \item Esta fila com prioridades é implementada através de uma \textit{heap} binária

        \item Esta estratégia permite que os métodos \code{c}{push()} e \code{c}{pop()} sejam
            implementados com complexidade $O(\log N)$

        \item Diferentente da fila, para acessar o próximo elemento, segundo a
            prioridade estabelecida, é utilizado o método \code{c}{top()}

        \item Por padrão o maior elemento, segundo o critério de comparação, é o de maior 
            prioridade

        \item Este comportamento pode ser modificado através da reescrita do operador de
            comparação
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Exemplo de filas com prioridades}
    \inputsnippet{c++}{1}{21}{codes/priority.cpp}
\end{frame}

\begin{frame}[fragile]{Exemplo de filas com prioridades}
    \inputsnippet{c++}{22}{42}{codes/priority.cpp}
\end{frame}

\begin{frame}[fragile]{Min heap na STL}

    \begin{itemize}
        \item A \code{c}{priority_queue} da STL é uma \textit{max heap}

        \item Ela pode ser transformada em uma \textit{min heap} de duas maneiras

        \item A primeira dela é útil quando a fila armazena tipos numéricos

        \item Neste caso, basta inserir o simétrico de cada elemento na fila, o que inverterá
            o critério de comparação

        \item Deve-se, contudo, tomar o cuidado de utilizar o simétrico do elemento máximo,
            quando este for extraído

        \item A segunda maneira é utilizar a estrutura \code{c}{greater()} da STL, a qual 
            faz com que o operator \code{c}{>} seja utilizado nas comparações de ordenação

        \item Se a classe ou estrutura não tiver tal operador por padrão, o mesmo deve ser
            implementado
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Exemplo de min heap na STL}
    \inputsnippet{cpp}{1}{21}{codes/min.cpp}
\end{frame}

\begin{frame}[fragile]{Exemplo de min heap na STL}
    \inputsnippet{cpp}{22}{42}{codes/min.cpp}
\end{frame}
