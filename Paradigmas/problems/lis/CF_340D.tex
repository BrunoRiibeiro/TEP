\section{Codeforces Round \# 198 (Div. 2) -- Problem D: Bubble Sort Graph}

\begin{frame}[fragile]{Problema}

Iahub recently has learned Bubble Sort, an algorithm that is used to sort a permutation with 
$n$ elements $a_1, a_2, \ldots, a_n$ in ascending order. He is bored of this so simple 
algorithm, so he invents his own graph. The graph (let's call it $G$) initially has $n$ 
vertices and 0 edges. During Bubble Sort execution, edges appear as described in the following 
algorithm (pseudocode).

\end{frame}

\begin{frame}[fragile]{Problema}
    \inputsyntax{cpp}{codes/bubble.cpp}
\end{frame}

\begin{frame}[fragile]{Problema}

For a graph, an independent set is a set of vertices in a graph, no two of which are adjacent 
(so there are no edges between vertices of an independent set). A maximum independent set is an 
independent set which has maximum cardinality. Given the permutation, find the size of the 
maximum independent set of graph $G$, if we use such permutation as the premutation a in 
procedure \texttt{bubbleSortGraph}.

\end{frame}

\begin{frame}[fragile]{Entrada e saída}

\textbf{Input}

The first line of the input contains an integer $n$ ($2\leq n\leq 10^5$). The next line 
contains $n$ distinct integers $a_1, a_2, \ldots, a_n$ ($1\leq a_i\leq n$).

\vspace{0.2in}

\textbf{Output}

Output a single integer -- the answer to the problem.

\end{frame}

\begin{frame}[fragile]{Exemplo de entradas e saídas}

\begin{minipage}[t]{0.45\textwidth}
\textbf{Sample Input}
\begin{verbatim}
3
3 1 2
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
\textbf{Sample Output}
\begin{verbatim}
2
\end{verbatim}
\end{minipage}
\end{frame}

\begin{frame}[fragile]{Solução com complexidade $O(1)$}

    \begin{itemize}
        \item Observe que a tentativa de se computar o valor exato de $1378^n$ leva a dois
            problemas:
            \begin{enumerate}
                \item a complexidade da solução seria $O(n)$, e $n = 10^{9}$ no pior caso

                \item porém esta complexidade assume que o cálculo de cada produto pode ser
                    feito em $O(1)$, que não é o caso pois tais número crescem exponencialmente,
                    o que leva também a problemas de memória 
            \end{enumerate}

        \item Ainda assim, computar tais valores para os primeiros valores de $n$ (por exemplo,
            $n = 20$), pode revelar padrões na solução que não são óbvios à primeira vista

        \item O primeiro padrão que surge é que os últimos dígitos dos resultados, a partir de
            $n = 1$, formam uma sequência periódica: 
            \[
                8, 2, 4, 6, 8, 2, 4, 6, \ldots
            \] 

        \item Cuidado com o \textit{corner case} $n = 0$: neste caso, a resposta deve ser igual
            a um 

        \item Exceto no caso especial, uma operação de resto da divisão determina o 
            resultado correto, de modo que a solução tem complexidade $O(1)$
   \end{itemize}

\end{frame}

\begin{frame}[fragile]{Solução com complexidade $O(1)$}
    \inputsnippet{cpp}{1}{19}{codes/340D.cpp}
\end{frame}
