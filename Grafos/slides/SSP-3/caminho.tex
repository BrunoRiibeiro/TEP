\section{Caminhos mínimos}

\begin{frame}[fragile]{Identificação do caminho mínimo}

    \begin{itemize}
        \item Assim como nos algoritmos de Bellman-Ford e Dijkstra, é possível recuperar a 
            sequência de arestas que compõem o caminho mínimo

        \item Para determinar o caminho, é preciso manter o vetor bidimensional \code{c++}{pred}, 
            onde \code{c++}{pred[u][v]} é o nó que antecede $v$ no caminho mínimo que vai de $u$ a 
            $v$

        \item Inicialmente, todos os elementos deste vetor devem ser iguais a um valor sentinela,
            exceto em dois casos:

            \begin{enumerate}
                \item \code{c++}{pred[u][u] = u}
                \item \code{c++}{pred[u][v] = u}, se $(u, v)\in E$
            \end{enumerate}

        \item Se o vértice $k$ reduzir a distância \code{c}{dist[u][v]} (isto é, se
            \code{c}{dist[u][k] + dist[k][v] < dist[u][v]}), então o 
            \code{c++}{pred[u][v] = pred[k][v]}

        \item Deste modo, o caminho mínimo de $u$ a $v$ pode ser recuperado, passando por todos os 
            predecessores até se atingir o nó $u$
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Recuperação do caminho mínimo}
    \inputsnippet{c++}{1}{21}{floyd2.cpp}
\end{frame}

\begin{frame}[fragile]{Recuperação do caminho mínimo}
    \inputsnippet{c++}{23}{43}{floyd2.cpp}
\end{frame}

\begin{frame}[fragile]{Recuperação do caminho mínimo}
    \inputsnippet{c++}{44}{64}{floyd2.cpp}
\end{frame}

\begin{frame}[fragile]{Recuperação do caminho mínimo}
    \inputsnippet{c++}{65}{85}{floyd2.cpp}
\end{frame}
















