\section{Caminhos mínimos}

\begin{frame}[fragile]{Identificação do caminho mínimo}

    \begin{itemize}
        \item Assim como no algoritmo de Bellman-Ford, é possível recuperar a sequência de 
            arestas que compõem o caminho mínimo

        \item Para determinar o caminho, é preciso manter o vetor \code{c++}{pred}, onde
            \code{c++}{pred[u]} é o nó que antecede $u$ no caminho mínimo que vai de $s$ a 
            $u$

        \item Inicialmente, todos os elementos deste vetor devem ser iguais a um valor sentinela,
            exceto o vértice $s$, que terá \code{c++}{pred[s] = s}

        \item Se a aresta $(u, v)$ atualizar a distância \code{c++}{dist[v]}, então o 
            antecessor deve ser atualizado também: \code{c++}{pred[v] = u}

        \item Deste modo, o caminho pode ser recuperado, passando por todos os antecessores até
            se atingir o nó $s$

        \item Se o antecessor de $u$ for o valor sentinela, não há caminho de $s$ a $u$ no
            grafo
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Recuperação do caminho mínimo}
    \inputsnippet{c++}{1}{21}{dijkstra2.cpp}
\end{frame}

\begin{frame}[fragile]{Recuperação do caminho mínimo}
    \inputsnippet{c++}{22}{42}{dijkstra2.cpp}
\end{frame}

\begin{frame}[fragile]{Recuperação do caminho mínimo}
    \inputsnippet{c++}{43}{63}{dijkstra2.cpp}
\end{frame}

\begin{frame}[fragile]{Recuperação do caminho mínimo}
    \inputsnippet{c++}{64}{84}{dijkstra2.cpp}
\end{frame}
