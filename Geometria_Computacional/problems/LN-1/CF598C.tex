\section{Educational Codeforces Round 1 -- Problem C: Nearest vectors}

\begin{frame}[fragile]{Problema}

You are given the set of vectors on the plane, each of them starting at the origin. Your task is 
to find a pair of vectors with the minimal non-oriented angle between them.

Non-oriented angle is non-negative value, minimal between clockwise and counterclockwise direction 
angles. Non-oriented angle is always between 0 and $\pi$. For example, opposite directions vectors 
have angle equals to $\pi$.

\end{frame}

\begin{frame}[fragile]{Entrada e saída}

\textbf{Input}

First line of the input contains a single integer $n$ $(2 \leq n \leq 100 000)$ -- the number of 
vectors.

The $i$-th of the following $n$ lines contains two integers $x_i$ and $y_i$ $(|x|, |y| \leq 10 000, x^2 + y^2 > 0)$ -- the coordinates of the $i$-th vector. Vectors are numbered from 1 to $n$ in order of appearing in the input. It is guaranteed that no two vectors in the input share the same direction (but they still can have opposite directions).

\textbf{Output}

If the required point exists, output its coordinates, otherwise output -1.

\end{frame}

\begin{frame}[fragile]{Exemplo de entradas e saídas}

\begin{minipage}[t]{0.5\textwidth}
\textbf{Sample Input}
\begin{verbatim}
4
-1 0
0 -1
1 0
1 1

6
-1 0
0 -1
1 0
1 1
-4 -5
-4 -6
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\textbf{Sample Output}
\begin{verbatim}
3 4

6 5
\end{verbatim}
\end{minipage}
\end{frame}

\begin{frame}[fragile]{Observações sobre o problema}

    \begin{itemize}
        \item O ângulo que um vetor faz com o eixo-$x$ positivo pode ser computado com a 
            função \code{c}{atan2()} da biblioteca de matemática do C/C++

        \item É preciso observa que o retorno da função está no intervalo $[-\pi, \pi]$

        \item Uma vez ordenados os vetores por ângulo, basta computar o ângulo entre dois
            vetores consecutivos usando a diferença

        \item Por conta do retorno da função \code{c}{atan2()}, esta diferença pode ser 
            negativa

        \item Caso isto aconteça, basta somar $2\pi$ ao resultado

        \item O valor de $\pi$ pode ser computado através da expressão \code{c}{acos(-1.0)}

        \item Por fim, é preciso usar o tipo \code{c}{long double}, caso contrário o
            veredito será WA, por conta da precisão
    \end{itemize}

\end{frame}

\begin{frame}[fragile]{Solução AC com complexidade $O(n \log n)$}
    \inputsnippet{cpp}{1}{21}{ac2.cpp}
\end{frame}

\begin{frame}[fragile]{Solução AC com complexidade $O(n \log n)$}
    \inputsnippet{cpp}{22}{42}{ac2.cpp}
\end{frame}

\begin{frame}[fragile]{Solução AC com complexidade $O(n \log n)$}
    \inputsnippet{cpp}{44}{64}{ac2.cpp}
\end{frame}

\begin{frame}[fragile]{Solução AC usando aritmética inteira estendida}
    \inputsnippet{py}{1}{19}{ac2.py}
\end{frame}

\begin{frame}[fragile]{Solução AC usando aritmética inteira estendida}
    \inputsnippet{py}{20}{40}{ac2.py}
\end{frame}

\begin{frame}[fragile]{Solução AC usando aritmética inteira estendida}
    \inputsnippet{py}{41}{60}{ac2.py}
\end{frame}

\begin{frame}[fragile]{Solução AC usando aritmética inteira estendida}
    \inputsnippet{py}{61}{80}{ac2.py}
\end{frame}
