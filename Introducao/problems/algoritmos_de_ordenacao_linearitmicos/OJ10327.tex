\section{OJ 10327 -- Flip Sort}

\begin{frame}[fragile]{Problema}

Sorting in computer science is an important part. Almost every problem can be solved effeciently if
sorted data are found. There are some excellent sorting algorithm which has already acheived the 
lower bound $n\log n$. In this problem we will also discuss about a new sorting approach. In this 
approach only one operation (Flip) is available and that is you can exchange two adjacent terms. 
If you think a while, you will see that it is always possible to sort a set of numbers in this way.

A set of integers will be given. Now using the above approach we want to sort the numbers in
ascending order. You have to find out the minimum number of flips required. Such as to sort 
‘1 2 3’ we need no flip operation whether to sort ‘2 3 1’ we need at least 2 flip operations.

\end{frame}

\begin{frame}[fragile]{Entrada e saída}

\textbf{Input}

The input will start with a positive integer $N$ ($N\leq 1000$). In next few lines there will be 
$N$ integers.  

Input will be terminated by EOF.

\vspace{0.1in}

\textbf{Output}

For each data set print ‘\texttt{Minimum exchange operations :} $M$’ where $M$ is the minimum 
flip operations required to perform sorting. Use a seperate line for each case.

\end{frame}

\begin{frame}[fragile]{Exemplo de entradas e saídas}

\begin{minipage}[t]{0.4\textwidth}
\textbf{Exemplo de Entrada}
\begin{verbatim}
3
1 2 3
3
2 3 1
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{0.55\textwidth}
\textbf{Exemplo de Saída}
\begin{verbatim}
Minimum exchange operations : 0
Minimum exchange operations : 2
\end{verbatim}
\end{minipage}
\end{frame}

\begin{frame}[fragile]{Solução $O(N\log N)$}

    \begin{itemize}
        \item Observe que o problema consiste, de fato, na contagem das inversões existentes no
            vetor $a$

        \item Uma inversão consiste em um par de índices $(i, j)$, com $i < j$, tal que
            $a_i > a_j$

        \item Comparar todos os pares de índices possíveis leva a uma solução $O(N^2)$, a qual
            pode ser aceita, uma vez que $N\leq 10^3$

        \item Porém há uma solução mais eficiente, com complexidade $O(N\log N)$

        \item Basta observar que, durante a etapa de fusão do \textit{MergeSort}, é possível
            contar as inversões de forma eficiente

        \item Considere dois vetores $L$ e $R$ a serem fundidos, com $L$ à esquerda e $R$ à direita

        \item Para cada elemento de $L$ a ser copiado no vetor que conterá a fusão, haverão
            $r$ inversões associadas a este elemento, onde $r$ é o número de elementos do
            vetor $R$ já copiados 

        \item Logo a solução terá a mesma complexidade do \textit{MergeSort}
   \end{itemize}

\end{frame}

\begin{frame}[fragile]{Solução $O(N\log N)$}
    \inputsnippet{cpp}{1}{21}{codes/10327.cpp}
\end{frame}

\begin{frame}[fragile]{Solução $O(N\log N)$}
    \inputsnippet{cpp}{22}{42}{codes/10327.cpp}
\end{frame}

\begin{frame}[fragile]{Solução $O(N\log N)$}
    \inputsnippet{cpp}{43}{61}{codes/10327.cpp}
\end{frame}

\begin{frame}[fragile]{Solução $O(N\log N)$}
    \inputsnippet{cpp}{62}{82}{codes/10327.cpp}
\end{frame}
