\section{Exemplos de análise de complexidade assintótica}

\begin{frame}[fragile]{Exemplo 1}

	\textbf{Problema:} Implementar uma função que torne maíscula a primeira letra da string
        dada como parâmetro
	\vspace{0.1in}

	\textbf{Solução:} 
        \inputcode{cpp}{codes/capitalize.cpp}
	\vspace{0.2in}

	{\bf Complexidade: } A implementação da função faz uma única atribuição, de modo que, se
        a string tem $n$ caracteres, $f(n) = 1, \forall n$. Assim, o algoritmo tem complexidade
        $O(1)$.

\end{frame} 

\begin{frame}[fragile]{Exemplo 2}

	\textbf{Problema:} Implementar uma função que retorne a string dada, com a primeira letra 
        em maiúsculo
	\vspace{0.1in}

	\textbf{Solução:} 
        \inputcode{cpp}{codes/capitalize2.cpp}
	\vspace{0.2in}

	{\bf Complexidade: } Observe que os $n$ caracteres da string $s$ devem ser copiados em $r$,
        além da atribuição feita na linha 4. Assim, $f(n) = n + 1$, de modo que o algoritmo tem 
        complexidade $O(n)$.

\end{frame} 


\begin{frame}[fragile]{Exemplo 3}

    {\bf Problema:} Implementar uma função que retorne o produto cartesiano dos conjuntos
        de números inteiros $A$ e $B$.
	\vspace{0.1in}

    {\bf Solução:} 
        \inputcode{cpp}{codes/prod.cpp}
\end{frame} 

\begin{frame}[fragile]{Exemplo 3}

    {\bf Complexidade: } Na linha 4 são feitas duas atribuições (variáveis $n$ e $m$, 
        respectivamente). No início do laço externo (linha 6) é feita mais uma atribuição
        (\code{cpp}{i = 0}).

        A cada iteração do laço externo, são feitas 2 atribuições (\code{cpp}{j = 0} e o 
        incremento \code{cpp}{++i}, respectivamente). Como o laço externo é executado $n$ vezes, 
        são mais $2n$ atribuições.

        Em cada iteração do laço interno são feitas mais duas atribuições: o incremento 
        \code{cpp}{++j} e a adição do pair $(i, j)$ ao vetor \code{cpp}{P} por meio do método
        \code{cpp}{push_back()}. Como este método tem complexidade constante, ele equivale a 
        $c$ atribuições. Este laço será iniciado $n$ vezes, e em cada execução são $m$ iterações.
        Assim, serão mais
        \[
            \sum_{i = 0}^n\sum_{j = 0}^m (c + 1) = (c + 1)nm
        \]
        atribuições, de modo que $f(n, m) = 3 + 2n + (c + 1)nm$ é $O(nm)$.
\end{frame}

\begin{frame}[fragile]{Exemplo 4}

    {\bf Problema:} Implementar uma função que retorne todos os pares de naturais $(a, b)$ tais
        que $a < b \leq N$, para um inteiro positivo $N$ dado.
	\vspace{0.1in}

    {\bf Solução:} 
        \inputcode{cpp}{codes/pairs.cpp}
    \vspace{0.2in}

\end{frame}

\begin{frame}[fragile]{Exemplo 04}

	{\bf Problema:} Determinar o tamanho do maior subvetor ordenado de um 
	vetor \texttt{a} com \texttt{n} elementos.
	\vspace{0.1in}

    {\bf Algoritmo:} 
        \inputcode{cpp}{sorted.cpp}
    \vspace{0.2in}
    
	{\bf Complexidade } 

    {\it Caso 1: Vetor em ordem decrescente.} 
    2 atribuições no início, $4(n-1)$ no laço externo e $0$ no laço 
    interno. {Total de atribuições:} $2 + 4(n-1)$.  O algoritmo é $O(n)$.

\end{frame}

\begin{frame}[fragile]{Exemplo 04}

    {\it Caso 2: Vetor em ordem crescente.} 2 atribuições no 
    início, $4(n-1)$ no laço externo e 
    \[(n - 1) + \sum_{i=0}^{n-2} \left[2(n - 1 - i)\right] = (n - 1) + (n - 1)(n - 2) = (n - 1)^2\]
    no laço interno. {Total de atribuições:} 
    \[2 + 4(n-1) + (n-1)^2 = 2 + (n - 1)(n + 3)\]

    O algoritmo é $O(n^2)$. 

    \vspace{0.1in}
    Como determinar o caso médio?

\end{frame}

\begin{frame}[fragile]{Exemplo 05}

	{\bf Problema:} Realizar uma busca binária de um elemento \texttt{k} um vetor 
	ordenado de inteiros \texttt{a} de tamanho \texttt{n}.
	\vspace{0.1in}

    {\bf Algoritmo:} 
        \inputcode{cpp}{bs.cpp}
	\vspace{0.2in}
\end{frame}

\begin{frame}[fragile]{Exemplo 05}

    {\bf Complexidade} 
    \vspace{0.1in}

    {\it Caso 1: Chave no meio do vetor.} 2 atribuições no início, 
    $1$ no laço. {Total de atribuições:} $3$.  O algoritmo é $O(1)$.

    \vspace{0.1in}
    {\it Caso 2: Chave não está no vetor.} 2 atribuições no início, 
    laço executado $m$ vezes, onde $n/2^m = 1$.  {Total de atribuições:} $2 + 2\log n$. 
    O algoritmo é $O(\log n)$.

    \vspace{0.1in}
    Caso médio?
\end{frame}

\begin{frame}[fragile]{Exemplo 06}

	{\bf Problema:} Busca sequêncial de um elemento \texttt{k} em um vetor \texttt{a} 
	de tamanho \texttt{n}
	\vspace{0.1in}

	{\bf Algoritmo:} 
        \inputcode{cpp}{seq.cpp}
    \vspace{0.2in}

	{\bf Complexidade} 

	{\it Melhor caso: $k$ é o primeiro termo}. 1 atribuição no 
	início. {Total de atribuições:} $1$. 
	O algoritmo é $O(1)$.

	{\it Pior caso: $k$ não se encontra no vetor}. 1 atribuição no 
	início, $n$ no laço. {Total de atribuições:} 
	$1 + n$.  O algoritmo é $O(n)$.

\end{frame}

\begin{frame}[fragile]{Exemplo 06}

	{\it Caso médio: $k$ está em alguma das $n$ posições ou não 
	se encontra no vetor.} Considere a distribuição de probabilidade
	{uniforme} $p(\mbox{input}_i) = 1/(n+1)$. 

    Então
	\begin{align*}
	C_M &= \sum_{i=0}^{n} p(\mbox{input}_i)\mbox{steps}(\mbox{input}_i) \\ 
	&= \frac{1}{n+1}\left[\sum_{i=0}^{n-1} (i+1) + (n+1) \right]\\ 
	&= \frac{1}{n+1}\left[\frac{n(n+1)}{2} + (n+1)\right]= 
	\frac{n+2}{2}
	\end{align*}

	Logo, no caso médio, o algoritmo é $O(n)$.

\end{frame}

